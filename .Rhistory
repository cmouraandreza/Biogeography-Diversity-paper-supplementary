d$hc_cluster <- as.factor(hc_cluster)
# Primeiro, verifique a normalidade das variáveis
shapiro.test(scores_df$temperatura)
View(scores_df)
shapiro.test(scores_df$salinidade)
################################################################################
# testes
# Converter para numérico
scores_df$temperatura <- as.numeric(as.character(scores_df$temperatura))
# Primeiro, verifique a normalidade das variáveis
shapiro.test(scores_df$Temperatura)
shapiro.test(scores_df$Salinidade)
# Se normal -> Teste t
t.test(Temperatura ~ hc_cluster, data = scores_df)
t.test(Salinidade ~ hc_cluster, data = scores_df)
# Se NÃO normal -> Mann-Whitney
wilcox.test(Temperatura ~ hc_cluster, data = scores_df)
wilcox.test(Salinidade ~ hc_cluster, data = scores_df)
ggplot(scores_df, aes(x = as.factor(hc_cluster), y = Temperatura, fill = as.factor(hc_cluster))) +
geom_boxplot() +
theme_minimal() +
labs(title = "Temperatura por Cluster", x = "Cluster", y = "Temperatura")
ggplot(scores_df, aes(x = as.factor(hc_cluster), y = Salinidade, fill = as.factor(hc_cluster))) +
geom_boxplot() +
theme_minimal() +
labs(title = "Salinidade por Cluster", x = "Cluster", y = "Salinidade")
library(vegan)
# Rodar a PERMANOVA
permanova_result <- adonis2(d ~ as.factor(hc_cluster), data = scores_df)
# Ver o resultado
print(permanova_result)
# Carregar pacotes necessários
library(vegan)
library(cluster)
library(ggplot2)
library(dplyr)
library(ggrepel)
tecados <- readxl::read_xlsx('C:/Users/Andreza/Documents/GitHub/ATRIBUTOS/dados/PLANILHA_DOUT_ATRIBUTOS_NOVEM.xlsx',
sheet = 6)
analise_pcoa_gower_tec <- function(funcionais_tec, ambientais_tec) {
#filtrando os dados
tec_filt<-tecados[, c("CTH","DMH","H.margin","N.pattern","H.pattern","Temperatura","Salinidade" )]
# Preparação dos dados
tec_filt <- tec_filt %>%
mutate_if(is.character, as.factor)
funcionais_tec <- tec_filt[, c("CTH","DMH",
"H.margin","N.pattern","H.pattern")]
ambientais_tec <- tec_filt[, c("Temperatura","Salinidade")]
# daisy() lida automaticamente com variáveis mistas
dist_gower <- daisy(funcionais_tec, metric = "gower")
# Realizar PCoA
pcoa <- cmdscale(dist_gower, k = 2, eig = TRUE)
# Criar dataframe com scores da PCoA
scores_df <- data.frame(
PCo1 = pcoa$points[,1],
PCo2 = pcoa$points[,2],
Salinidade = ambientais_tec$Salinidade,
Temperatura = ambientais_tec$Temperatura
)
# Calcular correlações das variáveis com os eixos
# Para atributos funcionais
cor_func <- data.frame(
variavel = colnames(funcionais_tec),
tipo = "Atributos",
stringsAsFactors = FALSE
)
for(i in 1:ncol(funcionais_tec)) {
if(is.numeric(funcionais_tec[[i]])) {
cor_func$PCo1[i] <- cor(funcionais_tec[[i]], scores_df$PCo1, use = "complete.obs")
cor_func$PCo2[i] <- cor(funcionais_tec[[i]], scores_df$PCo2, use = "complete.obs")
} else {
# Para variáveis categóricas, usar análise de redundância
dummy <- model.matrix(~ funcionais_tec[[i]] - 1)
cor_func$PCo1[i] <- mean(cor(dummy, scores_df$PCo1))
cor_func$PCo2[i] <- mean(cor(dummy, scores_df$PCo2))
}
}
# Para variáveis ambientais
cor_amb <- data.frame(
variavel = colnames(ambientais_tec),
PCo1 = NA,
PCo2 = NA,
tipo = "Ambientais",
stringsAsFactors = FALSE
)
for(i in 1:ncol(ambientais_tec)) {
cor_amb$PCo1[i] <- cor(ambientais_tec[[i]], scores_df$PCo1, use = "complete.obs")
cor_amb$PCo2[i] <- cor(ambientais_tec[[i]], scores_df$PCo2, use = "complete.obs")
}
# Combinar correlações
cor_todas <- rbind(cor_func, cor_amb)
# Calcular variância explicada
var_explicada <- (pcoa$eig / sum(pcoa$eig)) * 100
#cortando a salinidade
scores_df$Estrato_Salinidade <- cut(scores_df$Salinidade, breaks = 3)
# Nomeando os estratos
scores_df$Estrato_Salinidade <- cut(scores_df$Salinidade,
breaks = 3,
labels = c( "Média", "Alta", "Muito Alta"))
#PLOT ----
png('C:/Users/Andreza/Documents/GitHub/ATRIBUTOS/tecados_pcoa.png',
width = 3000, height = 3000, res = 300 )
ggplot() +
# Pontos das observações
geom_point(data = scores_df, aes(x = PCo1, y = PCo2, fill = Estrato_Salinidade),
shape = 21, size = 4, alpha = 0.6, color = "white") +
scale_fill_manual(values = c(
"Média" = "#3B528BFF",
"Alta" = "#21908CFF",
"Muito Alta" = "gold")) +  # paleta inspirada no viridis
# Setas para variáveis
geom_segment(data = cor_todas,
aes(x = 0, y = 0, xend = PCo1 * 2, yend = PCo2 * 2,
color = tipo),
arrow = arrow(length = unit(0.2, "cm"))) +
# Labels das variáveis
geom_text_repel(data = cor_todas,
aes(x = PCo1 * 2, y = PCo2 * 2,
label = variavel, color = tipo),
size = 5) +
# Personalização
scale_color_manual(values = c("Atributos" = "black",
"Ambientais" = "red")) +
labs(
x = paste0("PCoA1 (", round(var_explicada[1], 2), "%)"),
y = paste0("PCoA2 (", round(var_explicada[2], 2), "%)"),
color = "Tipo de Variável"
) +
theme(
#panel.grid = element_blank(),
axis.text.y = element_text(angle = 90, hjust = 0.5), # Gira os números da latitude
panel.background = element_rect(fill = "white"),  # fundo branco
panel.border = element_rect(color = "gray", fill = NA),
legend.position = "top",  # legenda horizontal embaixo
legend.direction = "horizontal"
) +
coord_equal()+
annotate("text", x = -Inf, y = Inf, label = "(b)", hjust = -0.2, vjust = 1.2,
fontface = "bold", size = 8)
dev.off()
}
analise_pcoa_gower_tec()
analise_pcoa_gower_tec <- function(funcionais_tec, ambientais_tec) {
#filtrando os dados
tec_filt<-tecados[, c("CTH","DMH","H.margin","N.pattern","H.pattern","Temperatura","Salinidade" )]
# Preparação dos dados
tec_filt <- tec_filt %>%
mutate_if(is.character, as.factor)
funcionais_tec <- tec_filt[, c("CTH","DMH",
"H.margin","N.pattern","H.pattern")]
ambientais_tec <- tec_filt[, c("Temperatura","Salinidade")]
# daisy() lida automaticamente com variáveis mistas
dist_gower <- daisy(funcionais_tec, metric = "gower")
# Realizar PCoA
pcoa <- cmdscale(dist_gower, k = 2, eig = TRUE)
# Criar dataframe com scores da PCoA
scores_df <- data.frame(
PCo1 = pcoa$points[,1],
PCo2 = pcoa$points[,2],
Salinidade = ambientais_tec$Salinidade,
Temperatura = ambientais_tec$Temperatura
)
# Calcular correlações das variáveis com os eixos
# Para atributos funcionais
cor_func <- data.frame(
variavel = colnames(funcionais_tec),
tipo = "Atributos",
stringsAsFactors = FALSE
)
for(i in 1:ncol(funcionais_tec)) {
if(is.numeric(funcionais_tec[[i]])) {
cor_func$PCo1[i] <- cor(funcionais_tec[[i]], scores_df$PCo1, use = "complete.obs")
cor_func$PCo2[i] <- cor(funcionais_tec[[i]], scores_df$PCo2, use = "complete.obs")
} else {
# Para variáveis categóricas, usar análise de redundância
dummy <- model.matrix(~ funcionais_tec[[i]] - 1)
cor_func$PCo1[i] <- mean(cor(dummy, scores_df$PCo1))
cor_func$PCo2[i] <- mean(cor(dummy, scores_df$PCo2))
}
}
# Para variáveis ambientais
cor_amb <- data.frame(
variavel = colnames(ambientais_tec),
PCo1 = NA,
PCo2 = NA,
tipo = "Ambientais",
stringsAsFactors = FALSE
)
for(i in 1:ncol(ambientais_tec)) {
cor_amb$PCo1[i] <- cor(ambientais_tec[[i]], scores_df$PCo1, use = "complete.obs")
cor_amb$PCo2[i] <- cor(ambientais_tec[[i]], scores_df$PCo2, use = "complete.obs")
}
# Combinar correlações
cor_todas <- rbind(cor_func, cor_amb)
# Calcular variância explicada
var_explicada <- (pcoa$eig / sum(pcoa$eig)) * 100
#cortando a salinidade
scores_df$Estrato_Salinidade <- cut(scores_df$Salinidade, breaks = 3)
# Nomeando os estratos
scores_df$Estrato_Salinidade <- cut(scores_df$Salinidade,
breaks = 3,
labels = c( "Média", "Alta", "Muito Alta"))
#PLOT ----
png('C:/Users/Andreza/Documents/GitHub/ATRIBUTOS/tecados_pcoa.png',
width = 3000, height = 3000, res = 300 )
ggplot() +
# Pontos das observações
geom_point(data = scores_df, aes(x = PCo1, y = PCo2, fill = Estrato_Salinidade),
shape = 21, size = 4, alpha = 0.6, color = "white") +
scale_fill_manual(values = c(
"Média" = "#3B528BFF",
"Alta" = "#21908CFF",
"Muito Alta" = "gold")) +  # paleta inspirada no viridis
# Setas para variáveis
geom_segment(data = cor_todas,
aes(x = 0, y = 0, xend = PCo1 * 2, yend = PCo2 * 2,
color = tipo),
arrow = arrow(length = unit(0.2, "cm"))) +
# Labels das variáveis
geom_text_repel(data = cor_todas,
aes(x = PCo1 * 2, y = PCo2 * 2,
label = variavel, color = tipo),
size = 5) +
# Personalização
scale_color_manual(values = c("Atributos" = "black",
"Ambientais" = "red")) +
labs(
x = paste0("PCoA1 (", round(var_explicada[1], 2), "%)"),
y = paste0("PCoA2 (", round(var_explicada[2], 2), "%)"),
color = "Tipo de Variável"
) +
theme(
#panel.grid = element_blank(),
axis.text.y = element_text(angle = 90, hjust = 0.5), # Gira os números da latitude
panel.background = element_rect(fill = "white"),  # fundo branco
panel.border = element_rect(color = "gray", fill = NA),
legend.position = "top",  # legenda horizontal embaixo
legend.direction = "horizontal"
) +
coord_equal()+
annotate("text", x = -Inf, y = Inf, label = "(b)", hjust = -0.2, vjust = 1.2,
fontface = "bold", size = 8)
# dev.off()
}
analise_pcoa_gower_tec()
#filtrando os dados
tec_filt<-tecados[, c("CTH","DMH","H.margin","N.pattern","H.pattern","Temperatura","Salinidade" )]
# Preparação dos dados
tec_filt <- tec_filt %>%
mutate_if(is.character, as.factor)
funcionais_tec <- tec_filt[, c("CTH","DMH",
"H.margin","N.pattern","H.pattern")]
ambientais_tec <- tec_filt[, c("Temperatura","Salinidade")]
# daisy() lida automaticamente com variáveis mistas
dist_gower <- daisy(funcionais_tec, metric = "gower")
# Realizar PCoA
pcoa <- cmdscale(dist_gower, k = 2, eig = TRUE)
# Criar dataframe com scores da PCoA
scores_df <- data.frame(
PCo1 = pcoa$points[,1],
PCo2 = pcoa$points[,2],
Salinidade = ambientais_tec$Salinidade,
Temperatura = ambientais_tec$Temperatura
)
# Calcular correlações das variáveis com os eixos
# Para atributos funcionais
cor_func <- data.frame(
variavel = colnames(funcionais_tec),
tipo = "Atributos",
stringsAsFactors = FALSE
)
for(i in 1:ncol(funcionais_tec)) {
if(is.numeric(funcionais_tec[[i]])) {
cor_func$PCo1[i] <- cor(funcionais_tec[[i]], scores_df$PCo1, use = "complete.obs")
cor_func$PCo2[i] <- cor(funcionais_tec[[i]], scores_df$PCo2, use = "complete.obs")
} else {
# Para variáveis categóricas, usar análise de redundância
dummy <- model.matrix(~ funcionais_tec[[i]] - 1)
cor_func$PCo1[i] <- mean(cor(dummy, scores_df$PCo1))
cor_func$PCo2[i] <- mean(cor(dummy, scores_df$PCo2))
}
}
# Para variáveis ambientais
cor_amb <- data.frame(
variavel = colnames(ambientais_tec),
PCo1 = NA,
PCo2 = NA,
tipo = "Ambientais",
stringsAsFactors = FALSE
)
for(i in 1:ncol(ambientais_tec)) {
cor_amb$PCo1[i] <- cor(ambientais_tec[[i]], scores_df$PCo1, use = "complete.obs")
cor_amb$PCo2[i] <- cor(ambientais_tec[[i]], scores_df$PCo2, use = "complete.obs")
}
# Combinar correlações
cor_todas <- rbind(cor_func, cor_amb)
# Calcular variância explicada
var_explicada <- (pcoa$eig / sum(pcoa$eig)) * 100
#cortando a salinidade
scores_df$Estrato_Salinidade <- cut(scores_df$Salinidade, breaks = 3)
# Nomeando os estratos
scores_df$Estrato_Salinidade <- cut(scores_df$Salinidade,
breaks = 3,
labels = c( "Média", "Alta", "Muito Alta"))
ggplot() +
# Pontos das observações
geom_point(data = scores_df, aes(x = PCo1, y = PCo2, fill = Estrato_Salinidade),
shape = 21, size = 4, alpha = 0.6, color = "white") +
scale_fill_manual(values = c(
"Média" = "#3B528BFF",
"Alta" = "#21908CFF",
"Muito Alta" = "gold")) +  # paleta inspirada no viridis
# Setas para variáveis
geom_segment(data = cor_todas,
aes(x = 0, y = 0, xend = PCo1 * 2, yend = PCo2 * 2,
color = tipo),
arrow = arrow(length = unit(0.2, "cm"))) +
# Labels das variáveis
geom_text_repel(data = cor_todas,
aes(x = PCo1 * 2, y = PCo2 * 2,
label = variavel, color = tipo),
size = 5) +
# Personalização
scale_color_manual(values = c("Atributos" = "black",
"Ambientais" = "red")) +
labs(
x = paste0("PCoA1 (", round(var_explicada[1], 2), "%)"),
y = paste0("PCoA2 (", round(var_explicada[2], 2), "%)"),
color = "Tipo de Variável"
) +
theme(
#panel.grid = element_blank(),
axis.text.y = element_text(angle = 90, hjust = 0.5), # Gira os números da latitude
panel.background = element_rect(fill = "white"),  # fundo branco
panel.border = element_rect(color = "gray", fill = NA),
legend.position = "top",  # legenda horizontal embaixo
legend.direction = "horizontal"
) +
coord_equal()+
annotate("text", x = -Inf, y = Inf, label = "(b)", hjust = -0.2, vjust = 1.2,
fontface = "bold", size = 8)
# verificando envfit -----
# 10. Aplicar envfit
env <- envfit(scores_df[, c("PCo1", "PCo2")], cor_amb, permutations = 9999)
# verificando envfit -----
# 10. Aplicar envfit
env <- envfit(scores_df[, c("PCo1", "PCo2")], ambientais_tec, permutations = 9999)
# 11. Extrair vetores significativos (p < 0.05)
vetores_env <- as.data.frame(scores(env, display = "vectors"))
vetores_env$variavel <- rownames(vetores_env)
vetores_env$p_valor <- env$vectors$pvals
colnames(vetores_env)[1:2] <- c("Dim1", "Dim2")
vetores_env_sig <- vetores_env %>% filter(p_valor < 0.05)
vetores_env
View(vetores_env)
# salvando..
writexl::write_xlsx(list(
Autovalores = autovalores,
Scores_PCoA = scores_pcoa
), "C:/Users/Andreza/Documents/GitHub/ATRIBUTOS/PosDefesa/resultado_pcoa_tecados.xlsx")
# Autovalores da PCoA
autovalores <- data.frame(
Eixo = paste0("PCo", 1:length(pcoa$eig)),
Autovalor = as.numeric(pcoa$eig),
Variancia_Explicada = round((as.numeric(pcoa$eig) / sum(as.numeric(pcoa$eig))) * 100, 2)
)
autovalores
# salvando..
writexl::write_xlsx(list(
Autovalores = autovalores,
Scores_PCoA = scores_pcoa
), "C:/Users/Andreza/Documents/GitHub/ATRIBUTOS/PosDefesa/resultado_pcoa_tecados.xlsx")
# Coordenadas (scores das amostras nos eixos da PCoA)
scores_pcoa <- as.data.frame(pcoa$points)
colnames(scores_pcoa) <- c("PCo1", "PCo2")
pcoa_result$eig
pcoa$eig
# salvando..
writexl::write_xlsx(list(
Autovalores = autovalores,
Scores_PCoA = scores_pcoa
), "C:/Users/Andreza/Documents/GitHub/ATRIBUTOS/PosDefesa/resultado_pcoa_tecados.xlsx")
df3<-readxl::read_xlsx("C:/Users/Andreza/Documents/GitHub/Biogeografia/dados/Tabelas.cap.biogeografia.set2.xlsx", sheet = 1)
df3<-readxl::read_xlsx("C:/Users/Andreza/Documents/GitHub/Biogeografia/dados/Tabelas.cap.biogeografia.set2.xlsx", sheet = 1)
df_espalhado_fam<- spread(df3, key = Pais, value = Contagem)
df_espalhado_fam
# Transformar os dados para long format (necessário para o ggplot2)
dados_long <- tidyr::gather(df3, key = "Familia", value = "value", -Contagem)
dados_long1<-tidyr::gather(df3, value = "Familia")
#   esse gráfico ta tentando pegar os traits da tabela de atributos ----------
# Criar o gráfico de barras empilhadas
ggplot(dados_long, aes(x = Contagem, y = value, fill = Basal_arrangement)) +
geom_bar(stat = "identity", position = "fill") +   # position="fill" para barras empilhadas proporcionais
coord_flip() +                                     # Rotacionar o gráfico
labs(x = "Intervalo", y = "Proporção", fill = "Basal arrangement") +
theme_minimal() +                                  # Tema limpo
scale_fill_manual(values = c("monosiphonic" = "green", "polysiphonic" = "orange")) # Cores personalizadas
library(readr)
library(dplyr)
library(ggplot2)
library(geobr)
library(ggspatial)
library(rnaturalearth)
library(sf)
library(gridExtra)
library(writexl)
library(tidyverse)
library(devtools)
library(rnaturalearthhires)
library(vegan)
library(dplyr)
library(raster)
library(reshape2)
library(extrafont)
df3<-readxl::read_xlsx("C:/Users/Andreza/Documents/GitHub/Biogeografia/dados/Tabelas.cap.biogeografia.set2.xlsx", sheet = 1)
View(df3)
setwd("C:/Users/Andreza/Documents/GitHub/Biogeography-Diversity-papper-supplementary")
setwd("C:/Users/Andreza/Documents/GitHub/Biogeography-Diversity-papper-supplementary")
setwd("C:/Users/Andreza/Documents/GitHub/Biogeography-Diversity-papper-supplementary")
top_10_generos<- readxl::read_xlsx("/top_10_gen.xlsx")
top_10_generos<- readxl::read_xlsx("Data/top_10_gen.xlsx")
top_10_fam<- readxl::read_xlsx("Data/top_10_fam.xlsx")
top_10_generos<- readxl::read_xlsx("Data/top_10_gen.xlsx")
windows(12,9)
# 2. usa o factor para unir os generos de acordo com a ordem
top_10_generos$Regions <- factor(top_10_generos$Regions, levels = c("CA", "BR", "UR/AR", "PA"))
top_10_generos <- top_10_generos %>%
mutate(genero = ifelse(Ordem == "A", paste0(genero, "*"), genero))
# Ordenar pela soma total da contagem por gênero (ordem decrescente)
top_10_generos <- top_10_generos %>%
group_by(genero) %>%
mutate(total = sum(contagem)) %>%
ungroup() %>%
mutate(genero = reorder(genero, -total))
plot.gen <- ggplot(top_10_generos, aes(y = contagem, x = genero, fill = Regions)) +
geom_bar(
position = "stack", stat = "identity", size = 0.4
) +
labs(y = "Species number", x = "Genus", fill = "Regions", color = "Regions") +
theme(
panel.grid = element_blank(),
axis.line = element_line(color = "black"),
rect = element_blank(),
axis.text.x = element_text(angle = 45, hjust = 1, face = "italic"),
text = element_text(size = 14),
legend.position = "none"  # excluindo legenda para ficar apenas
) +
scale_fill_manual(values = c("CA" = "#CD3A18", "BR" = "#1D6329",
"UR/AR" = "#91D6DE", "PA" = "#213778")) +
scale_color_manual(values = c("CA" = "#CD3A18", "BR" = "#1D6329",
"UR/AR" = "#91D6DE", "PA" = "#213778")) +
geom_text(
aes(label = ifelse(round(contagem, 1) > 1,
paste0(round(contagem, 1), "%"), "")),
size = 4,
position = position_stack(vjust = 0.5),
color = "white")
plot.gen
ggsave("Plot/genera.png",
plot = plot.gen, width = 10, height = 10, dpi = 300, units = "in")
ggsave("Plots/genera.png",
plot = plot.gen, width = 10, height = 10, dpi = 300, units = "in")
ggsave("Plots/family.png",
plot = plot.fam, width = 10, height = 10, dpi = 300, units = "in")
# 1.  Chamando od dados-----
top_10_fam<- readxl::read_xlsx("Data/top_10_fam.xlsx")
# 1. Substituir NA
top_10_fam$Regions[is.na(top_10_fam$Regions)] <- "UR/AR"
# 2. Criar marcação com * antes de agrupar
top_10_fam <- top_10_fam %>%
mutate(Family = ifelse(Ordem == "A", paste0(Family, "*"), Family))
# 3. Definir ordem dos níveis de Regions
top_10_fam$Regions <- factor(top_10_fam$Regions, levels = c("CA", "BR", "UR/AR", "PA"))
# 4. Ordenar por contagem total (sem repetir nomes!)
top_10_Family <- top_10_fam %>%
group_by(Family) %>%
mutate(total = sum(contagem)) %>%
ungroup() %>%
mutate(Family = reorder(Family, -total))
# 3. plot do grafico
plot.fam <- ggplot(top_10_Family, aes(y = contagem, x = Family, fill = Regions)) +
geom_bar(
position = "stack", stat = "identity", size = 0.4
) +
labs(y = "Species number", x = "Family", fill = "Regions", color = "Regions") +
theme(
panel.grid = element_blank(),
axis.line = element_line(color = "black"),
rect = element_blank(),
axis.text.x = element_text(angle = 45, hjust = 1),
text = element_text(size = 14),
legend.position = "none"  # excluindo legenda para ficar apenas
) +
scale_fill_manual(values = c("CA" = "#CD3A18", "BR" = "#1D6329",
"UR/AR" = "#91D6DE", "PA" = "#213778")) +
scale_color_manual(values = c("CA" = "#CD3A18", "BR" = "#1D6329",
"UR/AR" = "#91D6DE", "PA" = "#213778")) +
geom_text(
aes(label = ifelse(round(contagem, 1) > 1,
paste0(round(contagem, 1), "%"), "")),
size = 4,
position = position_stack(vjust = 0.5),
color = "white"
)
plot.fam
ggsave("Plots/family.png",
plot = plot.fam, width = 10, height = 10, dpi = 300, units = "in")
# gerando coluna de genero -----------------------------------------------------
#matriz de poresença
df<-readxl::read_xlsx("C:/Users/Andreza/Documents/GitHub/Biogeografia/Biogeografia_matriz_tratamentos_analise_atualizada_Junho.xlsx",
sheet = 2) # talvez tenha que mudar o numero do sheet
View(df)
